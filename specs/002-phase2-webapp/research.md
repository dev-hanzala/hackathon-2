# Research & Technology Decisions: Phase II

**Date**: 2026-01-10  
**Phase**: 0 (Research) - resolving technical unknowns  

---

## Backend Framework & Language

**Decision**: Python 3.13+ with FastAPI

**Rationale**:
- FastAPI provides automatic OpenAPI documentation and schema validation
- Async/await pattern scales well for I/O-bound tasks (DB queries, HTTP calls)
- SQLModel combines Pydantic (validation) + SQLAlchemy (ORM) for type safety
- Better Auth has official FastAPI integration
- Large ecosystem for auth, testing, async patterns
- Fast development iteration (dynamic typing with Pydantic validation)

**Alternatives Considered**:
- Node.js/Express: Simpler but less type safety; Better Auth support less mature
- Go: Excellent performance but steeper learning curve; overkill for MVP
- Rails: Rapid development but limits API-only design (more monolithic)

**Conclusion**: FastAPI balances speed, safety, and scalability for MVP.

---

## Frontend Framework

**Decision**: Next.js 16+ (App Router, TypeScript, Server Components)

**Rationale**:
- App Router (v13+) provides modern, file-based routing
- Built-in API routes for proxying to backend (helpful for CORS, debugging)
- TypeScript first-class support with strict mode
- Server Components reduce client-side JavaScript bundle
- TailwindCSS integration for rapid responsive design
- Vercel deployment with zero-config
- React Query (TanStack Query) for server state management

**Alternatives Considered**:
- React + Vite: Simpler but requires separate routing, deployment setup
- SvelteKit: Simpler syntax but smaller ecosystem
- Vue.js: Good framework but smaller community for enterprise patterns

**Conclusion**: Next.js provides most powerful developer experience and deployment options.

---

## Database & ORM

**Decision**: Neon Serverless PostgreSQL with SQLModel ORM

**Rationale**:
- Neon provides serverless, auto-scaling PostgreSQL
- No need to manage server infrastructure
- Connection pooling via Neon proxy
- SQLModel combines SQLAlchemy + Pydantic for type safety
- Alembic for migrations (standard in Python ecosystem)
- PostgreSQL JSONB and rich types support future extensibility

**Alternatives Considered**:
- MongoDB: Simpler schema initially but weaker relational constraints; harder to migrate later
- Firebase Firestore: Locked into Google; harder to migrate to open-source
- DynamoDB: Overkill for MVP; complex pricing model

**Conclusion**: Neon + PostgreSQL provides best balance of serverless simplicity + relational data safety.

---

## Authentication & Session Management

**Decision**: Better Auth (email/password) with JWT sessions

**Rationale**:
- Better Auth is production-ready, open-source auth framework
- Email/password auth sufficient for MVP; can extend to OAuth2 later
- Handles session creation, token refresh, logout
- Official FastAPI support
- Secure defaults: password hashing (bcrypt), CSRF protection, secure cookies

**Alternatives Considered**:
- Auth0: Managed service but vendor lock-in, cost implications
- Keycloak: Self-hosted but operational overhead for MVP
- Manual JWT implementation: High security risk, bugs common

**Conclusion**: Better Auth provides security + simplicity balance.

---

## API Design & Versioning

**Decision**: RESTful HTTP with URL path versioning (`/api/v1/...`)

**Rationale**:
- Familiar pattern; easier to test, debug, document
- URL path versioning allows multiple API versions running simultaneously
- OpenAPI/Swagger schema auto-generated by FastAPI
- Easy for frontend and future mobile clients to consume
- Versioning supports future breaking changes (v2, v3) without deprecation chaos

**Alternatives Considered**:
- GraphQL: More powerful but overkill for simple CRUD; steeper learning curve
- gRPC: Better performance but complexity not warranted; harder for web clients
- Header-based versioning: Less discoverable; harder to debug

**Conclusion**: URL-versioned REST is pragmatic balance of simplicity + forward-compatibility.

---

## Testing Strategy

**Decision**: Test Pyramid (Unit → Integration → E2E) with test-first approach

**Rationale**:
- **Unit Tests**: Service logic, validators (pytest)
- **Integration Tests**: API contract tests, auth flows, database interactions (pytest + httpx)
- **Frontend Tests**: Component tests (React Testing Library), integration flows (Cypress/Playwright optional)
- Test-first ensures spec compliance; TDD cycle catches bugs early
- Automated testing gates prevent regressions

**Technology Choices**:
- Backend: pytest (unit), pytest-asyncio (async), httpx (API testing)
- Frontend: Jest (unit), React Testing Library (component), Playwright (optional E2E)
- CI: GitHub Actions (runs tests on every commit)

**Coverage Goals**:
- Backend API: >80% coverage (at least all happy paths + error cases)
- Frontend: >70% coverage (component interactions, auth flows)
- Integration: All user stories have passing end-to-end test scenarios

---

## Concurrency & Conflict Resolution

**Decision**: Last-Write-Wins (optimistic approach, no version fields)

**Rationale**:
- MVP simplicity: no pessimistic locks or complex transaction logic
- Simultaneous edits of same task are rare in todo app context
- Users don't expect real-time sync (not collaborative tool)
- Trade-off: acceptable risk for MVP; can implement Optimistic Lock (version field) in Phase III if needed

**Risk Mitigation**:
- Front-end optimistic UI (task list updates immediately, rollback on error)
- User notifications if server rejects update (clear error messaging)
- Monitoring: log and alert on conflict patterns if they emerge

---

## Data Deletion Strategy (Soft vs Hard)

**Decision**: 
- **Completed tasks** → Soft-delete (archive via `is_archived = true`)
- **Explicitly deleted tasks** → Hard-delete (remove from DB)

**Rationale**:
- Completed tasks archived preserve audit trail and enable "undo complete" later
- Explicit deletes hard-deleted provide immediate cleanup for user (simple mental model)
- Balances user experience (can see what's done) with data preservation (audit trail)
- Easy to query active tasks: `WHERE completed = false AND is_archived = false`

**Schema Implication**:
```sql
ALTER TABLE tasks ADD COLUMN is_archived BOOLEAN DEFAULT FALSE;
```

---

## Frontend State Management & Data Fetching

**Decision**: React Query (TanStack Query) for server state + React Context for auth state

**Rationale**:
- React Query handles caching, refetching, background updates for task list
- Reduces boilerplate; automatic deduplication of identical requests
- Built-in dev tools for debugging state
- React Context simple enough for auth state (logged-in user, token)
- No Redux overkill for MVP

**Architecture**:
```typescript
// useAuth.ts - session state from Better Auth
// useTasks.ts - server state (useQuery, useMutation)
const { data: tasks, refetch } = useQuery(['tasks'], fetchTasks);
const createTaskMutation = useMutation(createTask, {
  onSuccess: () => refetch() // refetch after create
});
```

---

## Styling & Responsive Design

**Decision**: TailwindCSS for utility-first responsive design

**Rationale**:
- Rapid iteration: apply styles inline without context switching
- Mobile-first approach (responsive from 320px)
- Built into Next.js ecosystem
- Accessible components via Tailwind plugins

**Breakpoints**:
- Mobile: 320px (small phone) - default
- Tablet: 768px (`md:`)
- Desktop: 1024px (`lg:`)
- 4K: 1920px (`2xl:`)

---

## Deployment & Scalability

**Decision**: Serverless backend + CDN frontend (Phase II+)

**Rationale**:
- Vercel for frontend (Next.js native, auto-deployment from git, global CDN)
- Railway/Fly.io/Render for backend (serverless Python container, auto-scaling)
- Neon PostgreSQL serverless (auto-scales connections)
- No DevOps overhead for MVP

**Scaling Plan** (documented for future):
- Phase II: Monolithic deployment, 1000 concurrent users target
- Phase III: Separate services if needed (auth service, task service, notification service)
- Caching layer (Redis) if response times degrade
- Database read replicas if query load increases

---

## Security Considerations

**Decision**: 
- HTTPS only (enforced by deployment platform)
- CORS configured for frontend domain only
- CSRF tokens via Better Auth middleware
- Password hashing (bcrypt) enforced by Better Auth
- No secrets in `.env` files in git (use deployment platform secrets)

**Rate Limiting**: 
- Deferred to Phase III (can add via reverse proxy/middleware)
- Better Auth includes brute-force protection for auth endpoints

---

## Documentation & Developer Experience

**Decision**: OpenAPI schema + developer quickstart guide

**Rationale**:
- FastAPI auto-generates OpenAPI at `/api/v1/docs`
- Quickstart.md provides setup instructions (clone, env, docker-compose, first run)
- Type hints in code serve as inline documentation
- Tests serve as examples (test cases show API usage)

---

## Technology Stack Summary

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| **Language** | Python 3.13 | Type safety, FastAPI ecosystem, Better Auth support |
| **Backend** | FastAPI + SQLModel | Async, type-safe, OpenAPI docs, ORM |
| **Frontend** | Next.js 16 (TypeScript) | Modern React, file routing, Vercel deployment |
| **Database** | Neon PostgreSQL | Serverless, auto-scale, relational data |
| **Auth** | Better Auth | Production-ready, email/password, JWT sessions |
| **API** | REST + URL versioning | Familiar, scalable, self-documenting |
| **Testing** | pytest + Jest + React Testing Library | Complete coverage, fast feedback |
| **Styling** | TailwindCSS | Responsive, utility-first, rapid design |
| **Deployment** | Vercel (frontend) + Railway/Fly.io (backend) | Serverless, auto-scale, minimal ops |

---

## Open Questions (None - all clarified)

All technical unknowns resolved via clarifications Q1-Q5 and research above. Ready for Phase 1 design (data-model.md, contracts, quickstart).
