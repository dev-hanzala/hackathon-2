# Data Model: Phase II

**Date**: 2026-01-10  
**Phase**: 1 (Design)  
**Database**: Neon Serverless PostgreSQL

---

## Entity Relationship Diagram (ERD)

```
┌─────────────────┐
│ users           │
├─────────────────┤
│ id (PK, UUID)   │
│ email (UNIQUE)  │
│ password_hash   │
│ created_at      │
│ updated_at      │
└────────┬────────┘
         │
         │ 1:N (one user has many tasks)
         │
         ├────────────────────────────────────┐
         │                                    │
┌────────▼──────────────────┐      ┌──────────▼──────────────────┐
│ tasks                     │      │ sessions (Better Auth)       │
├───────────────────────────┤      ├─────────────────────────────┤
│ id (PK, UUID)             │      │ id (PK)                     │
│ user_id (FK)              │      │ user_id (FK)                │
│ title (VARCHAR)           │      │ token                       │
│ completed (BOOLEAN)       │      │ expires_at                  │
│ is_archived (BOOLEAN)     │      │ created_at                  │
│ created_at (TIMESTAMP)    │      └─────────────────────────────┘
│ updated_at (TIMESTAMP)    │
└──────────────────────────┘
```

---

## Entity Definitions

### 1. Users

**Purpose**: Stores user account information and authentication credentials

**Fields**:
| Field | Type | Constraints | Notes |
|-------|------|-----------|-------|
| `id` | UUID | PRIMARY KEY | Auto-generated by database |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | Used for login; validated format |
| `password_hash` | VARCHAR(255) | NOT NULL | Bcrypt hash (Better Auth handles) |
| `created_at` | TIMESTAMP | NOT NULL | Auto-set on creation |
| `updated_at` | TIMESTAMP | NOT NULL | Auto-set on creation/update |

**Validation Rules**:
- Email: Valid format (RFC 5322 simplified); unique per user
- Password hash: Non-empty; bcrypt or compatible (Better Auth enforces)
- Cannot update email (deferred to Phase III; consider email verification flow)

**Indexes**:
- UNIQUE INDEX on `email` (for login lookups)
- INDEX on `created_at` (for user analytics/audits)

**SQL**:
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

---

### 2. Tasks

**Purpose**: Stores todo items belonging to users

**Fields**:
| Field | Type | Constraints | Notes |
|-------|------|-----------|-------|
| `id` | UUID | PRIMARY KEY | Auto-generated; unique per task |
| `user_id` | UUID | FOREIGN KEY (users.id), NOT NULL | Establishes ownership |
| `title` | VARCHAR(500) | NOT NULL | Task title; max 500 chars |
| `completed` | BOOLEAN | NOT NULL DEFAULT FALSE | Marks task done (toggleable) |
| `is_archived` | BOOLEAN | NOT NULL DEFAULT FALSE | Soft-delete for completed tasks |
| `created_at` | TIMESTAMP | NOT NULL | Auto-set on creation |
| `updated_at` | TIMESTAMP | NOT NULL | Auto-set on mutations |

**Validation Rules**:
- Title: Non-empty, max 500 characters, trimmed whitespace
- Completed: Boolean (true/false only)
- is_archived: Boolean (true/false only); set to true when marking complete
- user_id: Must reference valid user (FK constraint enforced)
- Cannot create task without user_id (enforced at DB level)
- Last-Write-Wins conflict resolution uses the `updated_at` timestamp to determine latest update; no separate version field required for MVP.


**State Transitions**:
```
Created → [completed=false, is_archived=false]
  ↓
User marks complete → [completed=true, is_archived=true]  (soft-delete)
  ↓
User clicks "Delete" → hard-delete from DB (removed entirely)

Alternative flow:
User clicks "Delete" on incomplete task → hard-delete immediately
```

**Indexes**:
- FOREIGN KEY INDEX on `user_id` (for querying user's tasks)
- INDEX on `user_id, completed` (for active task list queries)
- INDEX on `user_id, is_archived` (for archive queries, if added)
- INDEX on `created_at` (for sorting, analytics)

**SQL**:
```sql
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(500) NOT NULL,
  completed BOOLEAN NOT NULL DEFAULT FALSE,
  is_archived BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);
CREATE INDEX idx_tasks_user_archived ON tasks(user_id, is_archived);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
```

**Cascade Delete**: When user is deleted, all their tasks are deleted (ON DELETE CASCADE).

---

### 3. Sessions

**Purpose**: Manages authenticated user sessions (provided by Better Auth)

**Fields** (Better Auth managed; documented for reference):
| Field | Type | Constraints | Notes |
|-------|------|-----------|-------|
| `id` | VARCHAR | PRIMARY KEY | Session token ID |
| `user_id` | UUID | FOREIGN KEY (users.id) | Links session to user |
| `token` | VARCHAR | NOT NULL | JWT or session token |
| `expires_at` | TIMESTAMP | NOT NULL | Token expiration time |
| `created_at` | TIMESTAMP | NOT NULL | Session creation time |

**Better Auth Handling**:
- Automatic table creation via Better Auth initialization
- Handles session creation on login
- Handles session cleanup/expiration
- Token validation on each request
- CSRF token generation for state-changing requests

**Notes**:
- Sessions managed entirely by Better Auth middleware
- Developer: No manual session insertion/deletion needed
- API: All endpoints check session validity via `@require_auth` decorator

---

## Query Patterns

### Active Tasks for User (Spec: View All Tasks)
```sql
SELECT id, title, completed, created_at, updated_at
FROM tasks
WHERE user_id = $1 AND completed = false AND is_archived = false
ORDER BY created_at DESC;
```
**Expected result**: All incomplete, non-archived tasks for user; newest first.

### Create Task (Spec: Add Task)
```sql
INSERT INTO tasks (user_id, title, completed, is_archived)
VALUES ($1, $2, false, false)
RETURNING id, title, completed, is_archived, created_at, updated_at;
```
**Expected result**: New task with generated ID.

### Mark Complete (Spec: Mark Task Complete)
```sql
UPDATE tasks
SET completed = true, is_archived = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $2
RETURNING id, title, completed, is_archived, updated_at;
```
**Expected result**: Updated task (now archived).

### Update Task (Spec: Update Task)
```sql
UPDATE tasks
SET title = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND user_id = $3
RETURNING id, title, completed, is_archived, updated_at;
```
**Expected result**: Updated task with new title.

### Delete Task (Spec: Delete Task)
```sql
DELETE FROM tasks
WHERE id = $1 AND user_id = $2;
```
**Expected result**: Task removed from database (hard-delete).

### User Login (Spec: Authentication)
```sql
SELECT id, email, password_hash
FROM users
WHERE email = $1;
```
**Expected result**: User record for password validation (Better Auth handles comparison).

### User Registration (Spec: Authentication)
```sql
INSERT INTO users (email, password_hash)
VALUES ($1, $2)
RETURNING id, email, created_at;
```
**Expected result**: New user with ID (Better Auth hashes password).

---

## Concurrency & Consistency

**Isolation Level**: READ_COMMITTED (PostgreSQL default) sufficient for MVP

**Conflict Resolution**: Last-Write-Wins
- No version fields (Clarification Q4)
- UPDATE queries use simple SET, not conditional WHERE version = X
- Latest timestamp (`updated_at`) wins if two writes occur simultaneously
- Acceptable for MVP (rare scenario in todo app)

**Data Integrity Constraints**:
- FK constraint: task.user_id must reference valid user
- NOT NULL constraints enforce required fields
- UNIQUE constraint on email prevents duplicate accounts
- Cascade delete on users ensures data cleanup

---

## Soft Delete vs Hard Delete (Clarification Q2)

**Completed Tasks** (Soft Delete / Archive):
```sql
UPDATE tasks SET is_archived = true WHERE id = $1;
```
- Row remains in database
- Excluded from active list queries (WHERE is_archived = false)
- Enables future "undo complete" or archive view
- Preserves audit trail

**Explicitly Deleted Tasks** (Hard Delete):
```sql
DELETE FROM tasks WHERE id = $1;
```
- Row removed entirely from database
- No recovery (unless backed up externally)
- Simplest UX: delete means gone
- Appropriate for explicit "Delete" action

---

## Migration Strategy (Alembic)

**Initial Migration** (`alembic/versions/001_initial_schema.py`):
```python
def upgrade():
    op.create_table(
        'users',
        sa.Column('id', sa.UUID(), nullable=False),
        sa.Column('email', sa.String(255), nullable=False),
        sa.Column('password_hash', sa.String(255), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')
    )
    op.create_table(
        'tasks',
        sa.Column('id', sa.UUID(), nullable=False),
        sa.Column('user_id', sa.UUID(), nullable=False),
        sa.Column('title', sa.String(500), nullable=False),
        sa.Column('completed', sa.Boolean(), nullable=False, server_default=sa.false()),
        sa.Column('is_archived', sa.Boolean(), nullable=False, server_default=sa.false()),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE')
    )
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_user_completed', 'tasks', ['user_id', 'completed'])
    op.create_index('idx_tasks_created_at', 'tasks', ['created_at'])

def downgrade():
    op.drop_index('idx_tasks_created_at')
    op.drop_index('idx_tasks_user_completed')
    op.drop_index('idx_tasks_user_id')
    op.drop_table('tasks')
    op.drop_table('users')
```

**Running migrations**:
```bash
alembic upgrade head  # Apply all pending migrations
alembic downgrade -1  # Rollback one migration
```

---

## Scalability Notes (Phase III+)

**Current Design** (Phase II MVP):
- Single PostgreSQL instance (Neon handles scaling)
- All queries synchronous
- No caching layer

**Future Considerations** (Phase III+):
- Read replicas for high-volume queries (e.g., task list analytics)
- Redis caching for frequently accessed tasks
- Background workers (Celery, Temporal) for async operations
- Database sharding if user count exceeds 10M+
- Connection pooling via PgBouncer if connection count spikes

---

## Testing & Validation

**Tests for Data Model**:
1. **User Creation**: Can create user with valid email, password hash stored securely
2. **Task Creation**: Can create task for user, ownership enforced
3. **Soft Delete**: Marking complete sets is_archived = true
4. **Hard Delete**: Deleting removes row from database
5. **Cascade Delete**: Deleting user deletes all their tasks
6. **Data Isolation**: User cannot query/modify another user's tasks
7. **Constraint Violations**: Attempting invalid state (null fields, invalid FK) raises error

---

## Summary

Phase II data model is minimal and focused:
- **2 entities**: users, tasks
- **Simple relationships**: 1 user : N tasks
- **Clear states**: completed (boolean), is_archived (soft-delete indicator)
- **Data integrity**: FK constraints, NOT NULL, UNIQUE email
- **Scalable**: Indexed for common queries, ready for caching layer in Phase III

All functional requirements (FR-001 through FR-017) are satisfied by this schema.
